Это можно сделать в один проход по массиву <script type="math/tex">a</script>. Каждый раз, когда мы встречаем элемент массива <script type="math/tex">b</script>, мы записываем его и его номер в специальные массивы. При этом мы поддерживаем в этих массивах отрезок <script type="math/tex">I</script>, на котором мы надеемся найти все различные элементы <script type="math/tex">b</script>. Ясно, что если очередной элемент массива <script type="math/tex">a</script> совпадает с первым элементом отрезка <script type="math/tex">I</script>, то <script type="math/tex">I</script> уже явно не может быть кратчайшим отрезком, удовлетворяющим условию задачи, и мы можем сдвинуть его левый конец. Если на очередном шаге мы понимаем, что <script type="math/tex">I</script> содержит все различные элементы <script type="math/tex">b</script>, то <script type="math/tex">I</script> &#8212; кандидат на ответ; в этом случае мы также сдвигаем его левый конец.<br>
Оценка <script type="math/tex">O(n)</script> по памяти очевидна. Оценка <script type="math/tex">O(nk)</script> по сложности может быть обоснована следующим образом: мы все делаем в один проход (отсюда <script type="math/tex">n</script>) и на каждом шаге должны искать элемент в массиве <script type="math/tex">b</script> (отсюда <script type="math/tex">k</script>). Ясно, что алгоритм можно улучшить: если вначале отсортировать <script type="math/tex">b</script> и использовать двоичный поиск, получим <script type="math/tex">O(n \log k)</script>. Если же использовать совершенное хеширование, то можно добиться сложности <script type="math/tex">O(n+k)</script>.
