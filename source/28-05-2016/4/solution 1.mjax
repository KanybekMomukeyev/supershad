Пронумеруем все начала отрезков <script type="math/tex">a_i</script> в порядке возрастания координаты. Если где-то координаты совпадают, порядок нумерации определяется по убыванию координат концов, если же и координаты концов совпадают &#8212; произвольным образом. Далее пронумеруем концы отрезков так, чтобы номер конца отрезка совпадал с номером его начала. Выпишем получившиеся номера концов отрезков в порядке убывания их координаты. Если где-то координаты совпадают &#8212; выписываем их в произвольном порядке. Сложность &#8212; <script type="math/tex">O(n \log n)</script>.<br>
В результате получилась некоторая перестановка <script type="math/tex">\sigma</script> чисел от <script type="math/tex">1</script> до <script type="math/tex">n</script>. Заметим, что индекс вложенности <script type="math/tex">i</script>-го отрезка равен количеству чисел, которые в этой перестановке одновременно<br>
(а) находятся левее (меньше по индексу) числа <script type="math/tex">i</script><br>
(б) меньше (по значению) числа <script type="math/tex">i</script><br>
Исключение составляют отрезки, которые полностью совпадают, но мы можем не обращать на это внимание, поскольку у одного из таких отрезков результат будет правильным (а у остальных &#8212; меньше), а следовательно, это не меняет ответ на вопрос задачи (считаем, что если отрезки совпадают, то каждый из них содержит все остальные).<br>
По перестановке <script type="math/tex">\sigma</script> мы можем найти массив <script type="math/tex">\beta</script> чисел, в котором число <script type="math/tex">\beta_i</script> равно количество таких чисел в перестановке <script type="math/tex">\sigma</script>, что они левее (меньше по индексу) и меньше (по значению) числа <script type="math/tex">\sigma_i</script>.<br>
Алгоритм нахождения <script type="math/tex">\beta</script> по <script type="math/tex">\sigma</script> практически идентичен классическому алгоритму нахождения таблицы инверсий по перестановке. Положим <script type="math/tex">\beta_i = 0, \,i=1\ldots n</script>. Пусть <script type="math/tex">k</script> пробегает 
значения от <script type="math/tex">\lfloor \lg n \rfloor</script> до <script type="math/tex">0</script> (иными словами, <script type="math/tex">k</script> пробегает количество цифр в двоичной записи максимального числа в <script type="math/tex">\sigma</script>). Для каждого <script type="math/tex">k</script> будем обнулять все счетчики <script type="math/tex">x_s: 0 \leqslant s \leqslant n/2^{k+1}</script> и для всех <script type="math/tex">j=1,2,\ldots,n</script> выполнять следующее: вычисляем <script type="math/tex">r=\lfloor \sigma_j/2^k \rfloor \mod 2</script>, <script type="math/tex">s = \lfloor \sigma_j/2^{k+1} \rfloor</script>; если <script type="math/tex">r=0</script>, то <script type="math/tex">x_s\mathrel{+}=1</script>, если же <script type="math/tex">r=1</script>, то <script type="math/tex">b_j\mathrel{+}=x_s</script>.<br>
По существу алгоритм делает следующее. Запишем все числа перестановки в двоичной системе и дополним слева нулями так, чтобы длина всех записей была одинакова. Тогда на шаге <script type="math/tex">k = \lfloor \lg n \rfloor</script> мы выписываем количество таких чисел в перестановке <script type="math/tex">\sigma</script>, что они меньше по индексу, а их старший бит меньше старшего бита числа <script type="math/tex">\sigma_i</script>. На шаге <script type="math/tex">k=\lfloor \lg n \rfloor - 1</script> мы решаем задачу уже для двух старших битов и так далее. Сложность &#8212; <script type="math/tex">O(n \log n)</script>. В итоге нам нужно проверить, есть ли в массиве <script type="math/tex">\beta</script> число, большее чем <script type="math/tex">1000</script>, что делается за <script type="math/tex">O(n)</script>. Итоговая сложность &#8212; <script type="math/tex">O(n \log n)</script>.
